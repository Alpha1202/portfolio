{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst convert_1 = require(\"./convert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst field_value_2 = require(\"./field-value\");\n\nconst geo_point_1 = require(\"./geo-point\");\n\nconst index_1 = require(\"./index\");\n\nconst path_1 = require(\"./path\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n */\n\n\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\n\nclass Serializer {\n  constructor(firestore) {\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = path => firestore.doc(path);\n  }\n  /**\n   * Encodes a JavaScript object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n\n\n  encodeFields(obj) {\n    const fields = {};\n\n    for (const prop of Object.keys(obj)) {\n      const val = this.encodeValue(obj[prop]);\n\n      if (val) {\n        fields[prop] = val;\n      }\n    }\n\n    return fields;\n  }\n  /**\n   * Encodes a JavaScript value into the Firestore 'Value' representation.\n   *\n   * @private\n   * @param val The object to encode\n   * @returns The Firestore Proto or null if we are deleting a field.\n   */\n\n\n  encodeValue(val) {\n    if (val instanceof field_value_1.FieldTransform) {\n      return null;\n    }\n\n    if (typeof val === 'string') {\n      return {\n        stringValue: val\n      };\n    }\n\n    if (typeof val === 'boolean') {\n      return {\n        booleanValue: val\n      };\n    }\n\n    if (typeof val === 'number') {\n      if (Number.isSafeInteger(val)) {\n        return {\n          integerValue: val\n        };\n      } else {\n        return {\n          doubleValue: val\n        };\n      }\n    }\n\n    if (val instanceof Date) {\n      const timestamp = timestamp_1.Timestamp.fromDate(val);\n      return {\n        timestampValue: {\n          seconds: timestamp.seconds,\n          nanos: timestamp.nanoseconds\n        }\n      };\n    }\n\n    if (val === null) {\n      return {\n        nullValue: 'NULL_VALUE'\n      };\n    }\n\n    if (val instanceof Buffer || val instanceof Uint8Array) {\n      return {\n        bytesValue: val\n      };\n    }\n\n    if (util_1.isObject(val)) {\n      const toProto = val['toProto'];\n\n      if (typeof toProto === 'function') {\n        return toProto.bind(val)();\n      }\n    }\n\n    if (val instanceof Array) {\n      const array = {\n        arrayValue: {}\n      };\n\n      if (val.length > 0) {\n        array.arrayValue.values = [];\n\n        for (let i = 0; i < val.length; ++i) {\n          const enc = this.encodeValue(val[i]);\n\n          if (enc) {\n            array.arrayValue.values.push(enc);\n          }\n        }\n      }\n\n      return array;\n    }\n\n    if (typeof val === 'object' && isPlainObject(val)) {\n      const map = {\n        mapValue: {}\n      }; // If we encounter an empty object, we always need to send it to make sure\n      // the server creates a map entry.\n\n      if (!util_1.isEmpty(val)) {\n        map.mapValue.fields = this.encodeFields(val);\n\n        if (util_1.isEmpty(map.mapValue.fields)) {\n          return null;\n        }\n      }\n\n      return map;\n    }\n\n    throw new Error(`Cannot encode value: ${val}`);\n  }\n  /**\n   * Decodes a single Firestore 'Value' Protobuf.\n   *\n   * @private\n   * @param proto A Firestore 'Value' Protobuf.\n   * @returns The converted JS type.\n   */\n\n\n  decodeValue(proto) {\n    const valueType = convert_1.detectValueType(proto);\n\n    switch (valueType) {\n      case 'stringValue':\n        {\n          return proto.stringValue;\n        }\n\n      case 'booleanValue':\n        {\n          return proto.booleanValue;\n        }\n\n      case 'integerValue':\n        {\n          return Number(proto.integerValue);\n        }\n\n      case 'doubleValue':\n        {\n          return Number(proto.doubleValue);\n        }\n\n      case 'timestampValue':\n        {\n          const timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n          return timestamp;\n        }\n\n      case 'referenceValue':\n        {\n          const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n          return this.createReference(resourcePath.relativeName);\n        }\n\n      case 'arrayValue':\n        {\n          const array = [];\n\n          if (Array.isArray(proto.arrayValue.values)) {\n            for (const value of proto.arrayValue.values) {\n              array.push(this.decodeValue(value));\n            }\n          }\n\n          return array;\n        }\n\n      case 'nullValue':\n        {\n          return null;\n        }\n\n      case 'mapValue':\n        {\n          const obj = {};\n          const fields = proto.mapValue.fields;\n\n          if (fields) {\n            for (const prop of Object.keys(fields)) {\n              obj[prop] = this.decodeValue(fields[prop]);\n            }\n          }\n\n          return obj;\n        }\n\n      case 'geoPointValue':\n        {\n          return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n        }\n\n      case 'bytesValue':\n        {\n          return proto.bytesValue;\n        }\n\n      default:\n        {\n          throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n        }\n    }\n  }\n\n}\n\nexports.Serializer = Serializer;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\n\nfunction isPlainObject(input) {\n  return util_1.isObject(input) && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);\n}\n\nexports.isPlainObject = isPlainObject;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether deletes are allowed in conjunction with `allowDeletes: root`.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\n\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n  if (path && path.size > MAX_DEPTH) {\n    throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);\n  }\n\n  options = options || {};\n  level = level || 0;\n  inArray = inArray || false;\n  const fieldPathMessage = path ? ` (found in field ${path})` : '';\n\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; ++i) {\n      validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1,\n      /* inArray= */\n      true);\n    }\n  } else if (isPlainObject(value)) {\n    for (const prop of Object.keys(value)) {\n      validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n    }\n  } else if (value === undefined) {\n    throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use \"undefined\" as a Firestore value${fieldPathMessage}.`);\n  } else if (value instanceof field_value_2.DeleteTransform) {\n    if (inArray) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n    } else if (options.allowDeletes === 'root' && level !== 0 || options.allowDeletes === 'none') {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() or set() with {merge:true}${fieldPathMessage}.`);\n    }\n  } else if (value instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n    } else if (!options.allowTransforms) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);\n    }\n  } else if (value instanceof path_1.FieldPath) {\n    throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use object of type \"FieldPath\" as a Firestore value${fieldPathMessage}.`);\n  } else if (value instanceof index_1.DocumentReference) {// Ok.\n  } else if (value instanceof geo_point_1.GeoPoint) {// Ok.\n  } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {// Ok.\n  } else if (value instanceof Buffer || value instanceof Uint8Array) {// Ok.\n  } else if (value === null) {// Ok.\n  } else if (typeof value === 'object') {\n    throw new Error(validate_1.customObjectMessage(arg, value, path));\n  }\n}\n\nexports.validateUserInput = validateUserInput;","map":{"version":3,"sources":["/Users/mac/Desktop/my-portfolio-website/node_modules/@google-cloud/firestore/build/src/serializer.js"],"names":["Object","defineProperty","exports","value","convert_1","require","field_value_1","field_value_2","geo_point_1","index_1","path_1","timestamp_1","util_1","validate_1","MAX_DEPTH","Serializer","constructor","firestore","createReference","path","doc","encodeFields","obj","fields","prop","keys","val","encodeValue","FieldTransform","stringValue","booleanValue","Number","isSafeInteger","integerValue","doubleValue","Date","timestamp","Timestamp","fromDate","timestampValue","seconds","nanos","nanoseconds","nullValue","Buffer","Uint8Array","bytesValue","isObject","toProto","bind","Array","array","arrayValue","length","values","i","enc","push","isPlainObject","map","mapValue","isEmpty","Error","decodeValue","proto","valueType","detectValueType","fromProto","resourcePath","QualifiedResourcePath","fromSlashSeparatedString","referenceValue","relativeName","isArray","GeoPoint","geoPointValue","JSON","stringify","input","getPrototypeOf","prototype","validateUserInput","arg","desc","options","level","inArray","size","invalidArgumentMessage","fieldPathMessage","append","String","FieldPath","undefined","DeleteTransform","methodName","allowDeletes","allowTransforms","DocumentReference","customObjectMessage"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst convert_1 = require(\"./convert\");\nconst field_value_1 = require(\"./field-value\");\nconst field_value_2 = require(\"./field-value\");\nconst geo_point_1 = require(\"./geo-point\");\nconst index_1 = require(\"./index\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n */\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\nclass Serializer {\n    constructor(firestore) {\n        // Instead of storing the `firestore` object, we store just a reference to\n        // its `.doc()` method. This avoid a circular reference, which breaks\n        // JSON.stringify().\n        this.createReference = path => firestore.doc(path);\n    }\n    /**\n     * Encodes a JavaScript object into the Firestore 'Fields' representation.\n     *\n     * @private\n     * @param obj The object to encode.\n     * @returns The Firestore 'Fields' representation\n     */\n    encodeFields(obj) {\n        const fields = {};\n        for (const prop of Object.keys(obj)) {\n            const val = this.encodeValue(obj[prop]);\n            if (val) {\n                fields[prop] = val;\n            }\n        }\n        return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n    encodeValue(val) {\n        if (val instanceof field_value_1.FieldTransform) {\n            return null;\n        }\n        if (typeof val === 'string') {\n            return {\n                stringValue: val,\n            };\n        }\n        if (typeof val === 'boolean') {\n            return {\n                booleanValue: val,\n            };\n        }\n        if (typeof val === 'number') {\n            if (Number.isSafeInteger(val)) {\n                return {\n                    integerValue: val,\n                };\n            }\n            else {\n                return {\n                    doubleValue: val,\n                };\n            }\n        }\n        if (val instanceof Date) {\n            const timestamp = timestamp_1.Timestamp.fromDate(val);\n            return {\n                timestampValue: {\n                    seconds: timestamp.seconds,\n                    nanos: timestamp.nanoseconds,\n                },\n            };\n        }\n        if (val === null) {\n            return {\n                nullValue: 'NULL_VALUE',\n            };\n        }\n        if (val instanceof Buffer || val instanceof Uint8Array) {\n            return {\n                bytesValue: val,\n            };\n        }\n        if (util_1.isObject(val)) {\n            const toProto = val['toProto'];\n            if (typeof toProto === 'function') {\n                return toProto.bind(val)();\n            }\n        }\n        if (val instanceof Array) {\n            const array = {\n                arrayValue: {},\n            };\n            if (val.length > 0) {\n                array.arrayValue.values = [];\n                for (let i = 0; i < val.length; ++i) {\n                    const enc = this.encodeValue(val[i]);\n                    if (enc) {\n                        array.arrayValue.values.push(enc);\n                    }\n                }\n            }\n            return array;\n        }\n        if (typeof val === 'object' && isPlainObject(val)) {\n            const map = {\n                mapValue: {},\n            };\n            // If we encounter an empty object, we always need to send it to make sure\n            // the server creates a map entry.\n            if (!util_1.isEmpty(val)) {\n                map.mapValue.fields = this.encodeFields(val);\n                if (util_1.isEmpty(map.mapValue.fields)) {\n                    return null;\n                }\n            }\n            return map;\n        }\n        throw new Error(`Cannot encode value: ${val}`);\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n    decodeValue(proto) {\n        const valueType = convert_1.detectValueType(proto);\n        switch (valueType) {\n            case 'stringValue': {\n                return proto.stringValue;\n            }\n            case 'booleanValue': {\n                return proto.booleanValue;\n            }\n            case 'integerValue': {\n                return Number(proto.integerValue);\n            }\n            case 'doubleValue': {\n                return Number(proto.doubleValue);\n            }\n            case 'timestampValue': {\n                const timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n                return timestamp;\n            }\n            case 'referenceValue': {\n                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n                return this.createReference(resourcePath.relativeName);\n            }\n            case 'arrayValue': {\n                const array = [];\n                if (Array.isArray(proto.arrayValue.values)) {\n                    for (const value of proto.arrayValue.values) {\n                        array.push(this.decodeValue(value));\n                    }\n                }\n                return array;\n            }\n            case 'nullValue': {\n                return null;\n            }\n            case 'mapValue': {\n                const obj = {};\n                const fields = proto.mapValue.fields;\n                if (fields) {\n                    for (const prop of Object.keys(fields)) {\n                        obj[prop] = this.decodeValue(fields[prop]);\n                    }\n                }\n                return obj;\n            }\n            case 'geoPointValue': {\n                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n            }\n            case 'bytesValue': {\n                return proto.bytesValue;\n            }\n            default: {\n                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n            }\n        }\n    }\n}\nexports.Serializer = Serializer;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\nfunction isPlainObject(input) {\n    return (util_1.isObject(input) &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null));\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether deletes are allowed in conjunction with `allowDeletes: root`.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n    if (path && path.size > MAX_DEPTH) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);\n    }\n    options = options || {};\n    level = level || 0;\n    inArray = inArray || false;\n    const fieldPathMessage = path ? ` (found in field ${path})` : '';\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; ++i) {\n            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, \n            /* inArray= */ true);\n        }\n    }\n    else if (isPlainObject(value)) {\n        for (const prop of Object.keys(value)) {\n            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n        }\n    }\n    else if (value === undefined) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use \"undefined\" as a Firestore value${fieldPathMessage}.`);\n    }\n    else if (value instanceof field_value_2.DeleteTransform) {\n        if (inArray) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if ((options.allowDeletes === 'root' && level !== 0) ||\n            options.allowDeletes === 'none') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() or set() with {merge:true}${fieldPathMessage}.`);\n        }\n    }\n    else if (value instanceof field_value_1.FieldTransform) {\n        if (inArray) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if (!options.allowTransforms) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);\n        }\n    }\n    else if (value instanceof path_1.FieldPath) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use object of type \"FieldPath\" as a Firestore value${fieldPathMessage}.`);\n    }\n    else if (value instanceof index_1.DocumentReference) {\n        // Ok.\n    }\n    else if (value instanceof geo_point_1.GeoPoint) {\n        // Ok.\n    }\n    else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {\n        // Ok.\n    }\n    else if (value instanceof Buffer || value instanceof Uint8Array) {\n        // Ok.\n    }\n    else if (value === null) {\n        // Ok.\n    }\n    else if (typeof value === 'object') {\n        throw new Error(validate_1.customObjectMessage(arg, value, path));\n    }\n}\nexports.validateUserInput = validateUserInput;\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"script"}