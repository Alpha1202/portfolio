{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/mac/Desktop/my-portfolio-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\n\n\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   * @param clientDestructor A cleanup function that is called when a client is\n   * disposed of.\n   */\n  constructor(concurrentOperationLimit, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     * @private\n     */\n\n    this.activeClients = new Map();\n    /**\n     * Whether the Firestore instance has been terminated. Once terminated, the\n     * ClientPool can longer schedule new operations.\n     */\n\n    this.terminated = false;\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   */\n\n\n  acquire(requestTag) {\n    let selectedClient = null;\n    let selectedRequestCount = 0;\n    this.activeClients.forEach((requestCount, client) => {\n      if (!selectedClient && requestCount < this.concurrentOperationLimit) {\n        logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - requestCount);\n        selectedClient = client;\n        selectedRequestCount = requestCount;\n      }\n    });\n\n    if (!selectedClient) {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n      selectedClient = this.clientFactory();\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n\n    this.activeClients.set(selectedClient, selectedRequestCount + 1);\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   */\n\n\n  async release(requestTag, client) {\n    let requestCount = this.activeClients.get(client) || 0;\n    assert(requestCount > 0, 'No active request');\n    requestCount = requestCount - 1;\n    this.activeClients.set(client, requestCount);\n\n    if (requestCount === 0) {\n      const deletedCount = await this.garbageCollect();\n\n      if (deletedCount) {\n        logger_1.logger('ClientPool.release', requestTag, 'Garbage collected %s clients', deletedCount);\n      }\n    }\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(count => activeOperationCount += count);\n    return activeOperationCount;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   */\n\n\n  run(requestTag, op) {\n    if (this.terminated) {\n      throw new Error('The client has already been terminated');\n    }\n\n    const client = this.acquire(requestTag);\n    return op(client).catch(async err => {\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n\n  async terminate() {\n    this.terminated = true;\n\n    for (const _ref of this.activeClients) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const client = _ref2[0];\n      const _requestCount = _ref2[1];\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n  /**\n   * Deletes clients that are no longer executing operations. Keeps up to one\n   * idle client to reduce future initialization costs.\n   *\n   * @return Number of clients deleted.\n   * @private\n   */\n\n\n  async garbageCollect() {\n    let idleClients = 0;\n    const cleanUpTasks = [];\n\n    for (const _ref3 of this.activeClients) {\n      var _ref4 = _slicedToArray(_ref3, 2);\n\n      const client = _ref4[0];\n      const requestCount = _ref4[1];\n\n      if (requestCount === 0) {\n        ++idleClients;\n\n        if (idleClients > 1) {\n          this.activeClients.delete(client);\n          cleanUpTasks.push(this.clientDestructor(client));\n        }\n      }\n    }\n\n    await Promise.all(cleanUpTasks);\n    return idleClients - 1;\n  }\n\n}\n\nexports.ClientPool = ClientPool;","map":{"version":3,"sources":["/Users/mac/Desktop/my-portfolio-website/node_modules/@google-cloud/firestore/build/src/pool.js"],"names":["Object","defineProperty","exports","value","assert","require","logger_1","ClientPool","constructor","concurrentOperationLimit","clientFactory","clientDestructor","Promise","resolve","activeClients","Map","terminated","acquire","requestTag","selectedClient","selectedRequestCount","forEach","requestCount","client","logger","has","set","release","get","deletedCount","garbageCollect","size","opCount","activeOperationCount","count","run","op","Error","catch","err","reject","then","res","terminate","_requestCount","delete","idleClients","cleanUpTasks","push","all"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;AAeAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;AACA;;;;;;;;;;;;AAUA,MAAME,UAAN,CAAiB;AACb;;;;;;;;AAQAC,EAAAA,WAAW,CAACC,wBAAD,EAA2BC,aAA3B,EAA0CC,gBAAgB,GAAG,MAAMC,OAAO,CAACC,OAAR,EAAnE,EAAsF;AAC7F,SAAKJ,wBAAL,GAAgCA,wBAAhC;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA;;;;;AAIA,SAAKG,aAAL,GAAqB,IAAIC,GAAJ,EAArB;AACA;;;;;AAIA,SAAKC,UAAL,GAAkB,KAAlB;AACH;AACD;;;;;;;;AAMAC,EAAAA,OAAO,CAACC,UAAD,EAAa;AAChB,QAAIC,cAAc,GAAG,IAArB;AACA,QAAIC,oBAAoB,GAAG,CAA3B;AACA,SAAKN,aAAL,CAAmBO,OAAnB,CAA2B,CAACC,YAAD,EAAeC,MAAf,KAA0B;AACjD,UAAI,CAACJ,cAAD,IAAmBG,YAAY,GAAG,KAAKb,wBAA3C,EAAqE;AACjEH,QAAAA,QAAQ,CAACkB,MAAT,CAAgB,oBAAhB,EAAsCN,UAAtC,EAAkD,uDAAlD,EAA2G,KAAKT,wBAAL,GAAgCa,YAA3I;AACAH,QAAAA,cAAc,GAAGI,MAAjB;AACAH,QAAAA,oBAAoB,GAAGE,YAAvB;AACH;AACJ,KAND;;AAOA,QAAI,CAACH,cAAL,EAAqB;AACjBb,MAAAA,QAAQ,CAACkB,MAAT,CAAgB,oBAAhB,EAAsCN,UAAtC,EAAkD,uBAAlD;AACAC,MAAAA,cAAc,GAAG,KAAKT,aAAL,EAAjB;AACAN,MAAAA,MAAM,CAAC,CAAC,KAAKU,aAAL,CAAmBW,GAAnB,CAAuBN,cAAvB,CAAF,EAA0C,2DAA1C,CAAN;AACH;;AACD,SAAKL,aAAL,CAAmBY,GAAnB,CAAuBP,cAAvB,EAAuCC,oBAAoB,GAAG,CAA9D;AACA,WAAOD,cAAP;AACH;AACD;;;;;;;AAKA,QAAMQ,OAAN,CAAcT,UAAd,EAA0BK,MAA1B,EAAkC;AAC9B,QAAID,YAAY,GAAG,KAAKR,aAAL,CAAmBc,GAAnB,CAAuBL,MAAvB,KAAkC,CAArD;AACAnB,IAAAA,MAAM,CAACkB,YAAY,GAAG,CAAhB,EAAmB,mBAAnB,CAAN;AACAA,IAAAA,YAAY,GAAGA,YAAY,GAAG,CAA9B;AACA,SAAKR,aAAL,CAAmBY,GAAnB,CAAuBH,MAAvB,EAA+BD,YAA/B;;AACA,QAAIA,YAAY,KAAK,CAArB,EAAwB;AACpB,YAAMO,YAAY,GAAG,MAAM,KAAKC,cAAL,EAA3B;;AACA,UAAID,YAAJ,EAAkB;AACdvB,QAAAA,QAAQ,CAACkB,MAAT,CAAgB,oBAAhB,EAAsCN,UAAtC,EAAkD,8BAAlD,EAAkFW,YAAlF;AACH;AACJ;AACJ;AACD;;;;;;AAMA;;;AACA,MAAIE,IAAJ,GAAW;AACP,WAAO,KAAKjB,aAAL,CAAmBiB,IAA1B;AACH;AACD;;;;;;AAMA;;;AACA,MAAIC,OAAJ,GAAc;AACV,QAAIC,oBAAoB,GAAG,CAA3B;AACA,SAAKnB,aAAL,CAAmBO,OAAnB,CAA2Ba,KAAK,IAAKD,oBAAoB,IAAIC,KAA7D;AACA,WAAOD,oBAAP;AACH;AACD;;;;;;;;;;;;;AAWAE,EAAAA,GAAG,CAACjB,UAAD,EAAakB,EAAb,EAAiB;AAChB,QAAI,KAAKpB,UAAT,EAAqB;AACjB,YAAM,IAAIqB,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,UAAMd,MAAM,GAAG,KAAKN,OAAL,CAAaC,UAAb,CAAf;AACA,WAAOkB,EAAE,CAACb,MAAD,CAAF,CACFe,KADE,CACI,MAAOC,GAAP,IAAe;AACtB,YAAM,KAAKZ,OAAL,CAAaT,UAAb,EAAyBK,MAAzB,CAAN;AACA,aAAOX,OAAO,CAAC4B,MAAR,CAAeD,GAAf,CAAP;AACH,KAJM,EAKFE,IALE,CAKG,MAAOC,GAAP,IAAe;AACrB,YAAM,KAAKf,OAAL,CAAaT,UAAb,EAAyBK,MAAzB,CAAN;AACA,aAAOmB,GAAP;AACH,KARM,CAAP;AASH;;AACD,QAAMC,SAAN,GAAkB;AACd,SAAK3B,UAAL,GAAkB,IAAlB;;AACA,uBAAsC,KAAKF,aAA3C,EAA0D;AAAA;;AAAA,YAA9CS,MAA8C;AAAA,YAAtCqB,aAAsC;AACtD,WAAK9B,aAAL,CAAmB+B,MAAnB,CAA0BtB,MAA1B;AACA,YAAM,KAAKZ,gBAAL,CAAsBY,MAAtB,CAAN;AACH;AACJ;AACD;;;;;;;;;AAOA,QAAMO,cAAN,GAAuB;AACnB,QAAIgB,WAAW,GAAG,CAAlB;AACA,UAAMC,YAAY,GAAG,EAArB;;AACA,wBAAqC,KAAKjC,aAA1C,EAAyD;AAAA;;AAAA,YAA7CS,MAA6C;AAAA,YAArCD,YAAqC;;AACrD,UAAIA,YAAY,KAAK,CAArB,EAAwB;AACpB,UAAEwB,WAAF;;AACA,YAAIA,WAAW,GAAG,CAAlB,EAAqB;AACjB,eAAKhC,aAAL,CAAmB+B,MAAnB,CAA0BtB,MAA1B;AACAwB,UAAAA,YAAY,CAACC,IAAb,CAAkB,KAAKrC,gBAAL,CAAsBY,MAAtB,CAAlB;AACH;AACJ;AACJ;;AACD,UAAMX,OAAO,CAACqC,GAAR,CAAYF,YAAZ,CAAN;AACA,WAAOD,WAAW,GAAG,CAArB;AACH;;AA7IY;;AA+IjB5C,OAAO,CAACK,UAAR,GAAqBA,UAArB","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         * @private\n         */\n        this.activeClients = new Map();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     */\n    acquire(requestTag) {\n        let selectedClient = null;\n        let selectedRequestCount = 0;\n        this.activeClients.forEach((requestCount, client) => {\n            if (!selectedClient && requestCount < this.concurrentOperationLimit) {\n                logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - requestCount);\n                selectedClient = client;\n                selectedRequestCount = requestCount;\n            }\n        });\n        if (!selectedClient) {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n            selectedClient = this.clientFactory();\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, selectedRequestCount + 1);\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     */\n    async release(requestTag, client) {\n        let requestCount = this.activeClients.get(client) || 0;\n        assert(requestCount > 0, 'No active request');\n        requestCount = requestCount - 1;\n        this.activeClients.set(client, requestCount);\n        if (requestCount === 0) {\n            const deletedCount = await this.garbageCollect();\n            if (deletedCount) {\n                logger_1.logger('ClientPool.release', requestTag, 'Garbage collected %s clients', deletedCount);\n            }\n        }\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(count => (activeOperationCount += count));\n        return activeOperationCount;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     */\n    run(requestTag, op) {\n        if (this.terminated) {\n            throw new Error('The client has already been terminated');\n        }\n        const client = this.acquire(requestTag);\n        return op(client)\n            .catch(async (err) => {\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        for (const [client, _requestCount] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n    /**\n     * Deletes clients that are no longer executing operations. Keeps up to one\n     * idle client to reduce future initialization costs.\n     *\n     * @return Number of clients deleted.\n     * @private\n     */\n    async garbageCollect() {\n        let idleClients = 0;\n        const cleanUpTasks = [];\n        for (const [client, requestCount] of this.activeClients) {\n            if (requestCount === 0) {\n                ++idleClients;\n                if (idleClients > 1) {\n                    this.activeClients.delete(client);\n                    cleanUpTasks.push(this.clientDestructor(client));\n                }\n            }\n        }\n        await Promise.all(cleanUpTasks);\n        return idleClients - 1;\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"script"}